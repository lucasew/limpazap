#!/usr/bin/env python3
import sys
import re
import subprocess
import argparse

def get_current_version(pubspec_path):
    with open(pubspec_path, 'r') as f:
        content = f.read()

    # Match version: x.y.z+n
    match = re.search(r'^version: (\d+)\.(\d+)\.(\d+)\+(\d+)', content, re.MULTILINE)
    if not match:
        raise ValueError("Could not find version in pubspec.yaml")

    return {
        'major': int(match.group(1)),
        'minor': int(match.group(2)),
        'patch': int(match.group(3)),
        'build': int(match.group(4)),
        'full_match': match.group(0),
        'content': content
    }

def increment_version(version_dict, part):
    new_version = version_dict.copy()
    new_version['build'] += 1

    if part == 'major':
        new_version['major'] += 1
        new_version['minor'] = 0
        new_version['patch'] = 0
    elif part == 'minor':
        new_version['minor'] += 1
        new_version['patch'] = 0
    elif part == 'patch':
        new_version['patch'] += 1
    elif part:
        # Assuming specific version string passed (though prompt focused on strategies)
        # This part is tricky if we want to support "set to specific version".
        # But the strategies usually just bump.
        # Let's try to parse the specific version if it looks like x.y.z
        parts = part.split('.')
        if len(parts) == 3:
             new_version['major'] = int(parts[0])
             new_version['minor'] = int(parts[1])
             new_version['patch'] = int(parts[2])
        else:
             print(f"Unknown increment type or invalid version format: {part}")
             sys.exit(1)

    return new_version

def update_pubspec(pubspec_path, old_version_dict, new_version_dict):
    new_version_str = f"version: {new_version_dict['major']}.{new_version_dict['minor']}.{new_version_dict['patch']}+{new_version_dict['build']}"
    new_content = old_version_dict['content'].replace(old_version_dict['full_match'], new_version_str)

    with open(pubspec_path, 'w') as f:
        f.write(new_content)

    return f"{new_version_dict['major']}.{new_version_dict['minor']}.{new_version_dict['patch']}+{new_version_dict['build']}"

def run_command(cmd, dry_run=False):
    print(f"Running: {cmd}")
    if not dry_run:
        subprocess.check_call(cmd, shell=True)

def main():
    parser = argparse.ArgumentParser(description='Bump version and release.')
    parser.add_argument('part', help='major, minor, patch, or specific version')
    parser.add_argument('--dry-run', action='store_true', help='Do not write to file or git commit/push')

    args = parser.parse_args()

    pubspec_path = 'pubspec.yaml'

    try:
        current_version = get_current_version(pubspec_path)
    except Exception as e:
        print(f"Error reading pubspec.yaml: {e}")
        sys.exit(1)

    new_version_dict = increment_version(current_version, args.part)

    new_version_str = f"{new_version_dict['major']}.{new_version_dict['minor']}.{new_version_dict['patch']}+{new_version_dict['build']}"
    print(f"New version: {new_version_str}")

    if not args.dry_run:
        update_pubspec(pubspec_path, current_version, new_version_dict)

    run_command("git add pubspec.yaml", args.dry_run)
    run_command(f'git commit -m "bump to {new_version_str}"', args.dry_run)
    run_command(f'git tag "{new_version_str}"', args.dry_run)
    run_command("git push", args.dry_run)
    run_command("git push --tags", args.dry_run)

if __name__ == '__main__':
    main()
